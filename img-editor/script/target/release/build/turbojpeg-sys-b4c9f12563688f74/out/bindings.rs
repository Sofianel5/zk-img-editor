/* automatically generated by rust-bindgen 0.57.0 */

pub const TJ_NUMINIT: u32 = 3;
pub const TJ_NUMSAMP: u32 = 7;
pub const TJ_NUMPF: u32 = 12;
pub const TJ_NUMCS: u32 = 5;
pub const TJ_NUMERR: u32 = 2;
pub const TJ_NUMXOP: u32 = 8;
pub const TJXOPT_PERFECT: u32 = 1;
pub const TJXOPT_TRIM: u32 = 2;
pub const TJXOPT_CROP: u32 = 4;
pub const TJXOPT_GRAY: u32 = 8;
pub const TJXOPT_NOOUTPUT: u32 = 16;
pub const TJXOPT_PROGRESSIVE: u32 = 32;
pub const TJXOPT_COPYNONE: u32 = 64;
pub const TJXOPT_ARITHMETIC: u32 = 128;
pub const TJXOPT_OPTIMIZE: u32 = 256;
pub const NUMSUBOPT: u32 = 7;
pub const TJ_BGR: u32 = 1;
pub const TJ_ALPHAFIRST: u32 = 64;
pub const TJ_YUV: u32 = 512;
pub const TJFLAG_BOTTOMUP: u32 = 2;
pub const TJFLAG_FORCEMMX: u32 = 8;
pub const TJFLAG_FORCESSE: u32 = 16;
pub const TJFLAG_FORCESSE2: u32 = 32;
pub const TJFLAG_FORCESSE3: u32 = 128;
pub const TJFLAG_FASTUPSAMPLE: u32 = 256;
pub const TJFLAG_NOREALLOC: u32 = 1024;
pub const TJFLAG_FASTDCT: u32 = 2048;
pub const TJFLAG_ACCURATEDCT: u32 = 4096;
pub const TJFLAG_STOPONWARNING: u32 = 8192;
pub const TJFLAG_PROGRESSIVE: u32 = 16384;
pub const TJFLAG_LIMITSCANS: u32 = 32768;
pub type size_t = libc::c_ulong;
pub type wchar_t = libc::c_int;
pub type max_align_t = f64;
#[doc = " Initialize the TurboJPEG instance for compression."]
pub const TJINIT_TJINIT_COMPRESS: TJINIT = 0;
#[doc = " Initialize the TurboJPEG instance for decompression."]
pub const TJINIT_TJINIT_DECOMPRESS: TJINIT = 1;
#[doc = " Initialize the TurboJPEG instance for lossless transformation (both"]
#[doc = " compression and decompression.)"]
pub const TJINIT_TJINIT_TRANSFORM: TJINIT = 2;
#[doc = " Initialization options."]
pub type TJINIT = libc::c_uint;
#[doc = " 4:4:4 chrominance subsampling (no chrominance subsampling).  The JPEG or"]
#[doc = " YUV image will contain one chrominance component for every pixel in the"]
#[doc = " source image."]
pub const TJSAMP_TJSAMP_444: TJSAMP = 0;
#[doc = " 4:2:2 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 2x1 block of pixels in the source image."]
pub const TJSAMP_TJSAMP_422: TJSAMP = 1;
#[doc = " 4:2:0 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 2x2 block of pixels in the source image."]
pub const TJSAMP_TJSAMP_420: TJSAMP = 2;
#[doc = " Grayscale.  The JPEG or YUV image will contain no chrominance components."]
pub const TJSAMP_TJSAMP_GRAY: TJSAMP = 3;
#[doc = " 4:4:0 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 1x2 block of pixels in the source image."]
#[doc = ""]
#[doc = " @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_440: TJSAMP = 4;
#[doc = " 4:1:1 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 4x1 block of pixels in the source image."]
#[doc = " JPEG images compressed with 4:1:1 subsampling will be almost exactly the"]
#[doc = " same size as those compressed with 4:2:0 subsampling, and in the"]
#[doc = " aggregate, both subsampling methods produce approximately the same"]
#[doc = " perceptual quality.  However, 4:1:1 is better able to reproduce sharp"]
#[doc = " horizontal features."]
#[doc = ""]
#[doc = " @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_411: TJSAMP = 5;
#[doc = " 4:4:1 chrominance subsampling.  The JPEG or YUV image will contain one"]
#[doc = " chrominance component for every 1x4 block of pixels in the source image."]
#[doc = " JPEG images compressed with 4:4:1 subsampling will be almost exactly the"]
#[doc = " same size as those compressed with 4:2:0 subsampling, and in the"]
#[doc = " aggregate, both subsampling methods produce approximately the same"]
#[doc = " perceptual quality.  However, 4:4:1 is better able to reproduce sharp"]
#[doc = " vertical features."]
#[doc = ""]
#[doc = " @note 4:4:1 subsampling is not fully accelerated in libjpeg-turbo."]
pub const TJSAMP_TJSAMP_441: TJSAMP = 6;
#[doc = " Unknown subsampling.  The JPEG image uses an unusual type of chrominance"]
#[doc = " subsampling.  Such images can be decompressed into packed-pixel images,"]
#[doc = " but they cannot be"]
#[doc = " - decompressed into planar YUV images,"]
#[doc = " - losslessly transformed if #TJXOPT_CROP is specified, or"]
#[doc = " - partially decompressed using a cropping region."]
pub const TJSAMP_TJSAMP_UNKNOWN: TJSAMP = -1;
#[doc = " Chrominance subsampling options."]
#[doc = " When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK"]
#[doc = " to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of"]
#[doc = " the Cb and Cr (chrominance) components can be discarded or averaged together"]
#[doc = " to produce a smaller image with little perceptible loss of image clarity."]
#[doc = " (The human eye is more sensitive to small changes in brightness than to"]
#[doc = " small changes in color.)  This is called \"chrominance subsampling\"."]
pub type TJSAMP = libc::c_int;
extern "C" {
    pub static tjMCUWidth: [libc::c_int; 7usize];
}
extern "C" {
    pub static tjMCUHeight: [libc::c_int; 7usize];
}
#[doc = " RGB pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 3-sample pixels in the order R, G, B from lowest to highest"]
#[doc = " memory address within each pixel."]
pub const TJPF_TJPF_RGB: TJPF = 0;
#[doc = " BGR pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 3-sample pixels in the order B, G, R from lowest to highest"]
#[doc = " memory address within each pixel."]
pub const TJPF_TJPF_BGR: TJPF = 1;
#[doc = " RGBX pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-sample pixels in the order R, G, B from lowest to highest"]
#[doc = " memory address within each pixel.  The X component is ignored when"]
#[doc = " compressing and undefined when decompressing."]
pub const TJPF_TJPF_RGBX: TJPF = 2;
#[doc = " BGRX pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-sample pixels in the order B, G, R from lowest to highest"]
#[doc = " memory address within each pixel.  The X component is ignored when"]
#[doc = " compressing and undefined when decompressing."]
pub const TJPF_TJPF_BGRX: TJPF = 3;
#[doc = " XBGR pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-sample pixels in the order R, G, B from highest to lowest"]
#[doc = " memory address within each pixel.  The X component is ignored when"]
#[doc = " compressing and undefined when decompressing."]
pub const TJPF_TJPF_XBGR: TJPF = 4;
#[doc = " XRGB pixel format.  The red, green, and blue components in the image are"]
#[doc = " stored in 4-sample pixels in the order B, G, R from highest to lowest"]
#[doc = " memory address within each pixel.  The X component is ignored when"]
#[doc = " compressing and undefined when decompressing."]
pub const TJPF_TJPF_XRGB: TJPF = 5;
#[doc = " Grayscale pixel format.  Each 1-sample pixel represents a luminance"]
#[doc = " (brightness) level from 0 to the maximum sample value (255 for 8-bit"]
#[doc = " samples, 4095 for 12-bit samples, and 65535 for 16-bit samples.)"]
pub const TJPF_TJPF_GRAY: TJPF = 6;
#[doc = " RGBA pixel format.  This is the same as @ref TJPF_RGBX, except that when"]
#[doc = " decompressing, the X component is guaranteed to be equal to the maximum"]
#[doc = " sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_RGBA: TJPF = 7;
#[doc = " BGRA pixel format.  This is the same as @ref TJPF_BGRX, except that when"]
#[doc = " decompressing, the X component is guaranteed to be equal to the maximum"]
#[doc = " sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_BGRA: TJPF = 8;
#[doc = " ABGR pixel format.  This is the same as @ref TJPF_XBGR, except that when"]
#[doc = " decompressing, the X component is guaranteed to be equal to the maximum"]
#[doc = " sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ABGR: TJPF = 9;
#[doc = " ARGB pixel format.  This is the same as @ref TJPF_XRGB, except that when"]
#[doc = " decompressing, the X component is guaranteed to be equal to the maximum"]
#[doc = " sample value, which can be interpreted as an opaque alpha channel."]
pub const TJPF_TJPF_ARGB: TJPF = 10;
#[doc = " CMYK pixel format.  Unlike RGB, which is an additive color model used"]
#[doc = " primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive"]
#[doc = " color model used primarily for printing.  In the CMYK color model, the"]
#[doc = " value of each color component typically corresponds to an amount of cyan,"]
#[doc = " magenta, yellow, or black ink that is applied to a white background.  In"]
#[doc = " order to convert between CMYK and RGB, it is necessary to use a color"]
#[doc = " management system (CMS.)  A CMS will attempt to map colors within the"]
#[doc = " printer's gamut to perceptually similar colors in the display's gamut and"]
#[doc = " vice versa, but the mapping is typically not 1:1 or reversible, nor can it"]
#[doc = " be defined with a simple formula.  Thus, such a conversion is out of scope"]
#[doc = " for a codec library.  However, the TurboJPEG API allows for compressing"]
#[doc = " packed-pixel CMYK images into YCCK JPEG images (see #TJCS_YCCK) and"]
#[doc = " decompressing YCCK JPEG images into packed-pixel CMYK images."]
pub const TJPF_TJPF_CMYK: TJPF = 11;
#[doc = " Unknown pixel format.  Currently this is only used by #tj3LoadImage8(),"]
#[doc = " #tj3LoadImage12(), and #tj3LoadImage16()."]
pub const TJPF_TJPF_UNKNOWN: TJPF = -1;
#[doc = " Pixel formats"]
pub type TJPF = libc::c_int;
extern "C" {
    pub static tjRedOffset: [libc::c_int; 12usize];
}
extern "C" {
    pub static tjGreenOffset: [libc::c_int; 12usize];
}
extern "C" {
    pub static tjBlueOffset: [libc::c_int; 12usize];
}
extern "C" {
    pub static tjAlphaOffset: [libc::c_int; 12usize];
}
extern "C" {
    pub static tjPixelSize: [libc::c_int; 12usize];
}
#[doc = " RGB colorspace.  When compressing the JPEG image, the R, G, and B"]
#[doc = " components in the source image are reordered into image planes, but no"]
#[doc = " colorspace conversion or subsampling is performed.  RGB JPEG images can be"]
#[doc = " compressed from and decompressed to packed-pixel images with any of the"]
#[doc = " extended RGB or grayscale pixel formats, but they cannot be compressed"]
#[doc = " from or decompressed to planar YUV images."]
pub const TJCS_TJCS_RGB: TJCS = 0;
#[doc = " YCbCr colorspace.  YCbCr is not an absolute colorspace but rather a"]
#[doc = " mathematical transformation of RGB designed solely for storage and"]
#[doc = " transmission.  YCbCr images must be converted to RGB before they can"]
#[doc = " actually be displayed.  In the YCbCr colorspace, the Y (luminance)"]
#[doc = " component represents the black & white portion of the original image, and"]
#[doc = " the Cb and Cr (chrominance) components represent the color portion of the"]
#[doc = " original image.  Originally, the analog equivalent of this transformation"]
#[doc = " allowed the same signal to drive both black & white and color televisions,"]
#[doc = " but JPEG images use YCbCr primarily because it allows the color data to be"]
#[doc = " optionally subsampled for the purposes of reducing network or disk usage."]
#[doc = " YCbCr is the most common JPEG colorspace, and YCbCr JPEG images can be"]
#[doc = " compressed from and decompressed to packed-pixel images with any of the"]
#[doc = " extended RGB or grayscale pixel formats.  YCbCr JPEG images can also be"]
#[doc = " compressed from and decompressed to planar YUV images."]
pub const TJCS_TJCS_YCbCr: TJCS = 1;
#[doc = " Grayscale colorspace.  The JPEG image retains only the luminance data (Y"]
#[doc = " component), and any color data from the source image is discarded."]
#[doc = " Grayscale JPEG images can be compressed from and decompressed to"]
#[doc = " packed-pixel images with any of the extended RGB or grayscale pixel"]
#[doc = " formats, or they can be compressed from and decompressed to planar YUV"]
#[doc = " images."]
pub const TJCS_TJCS_GRAY: TJCS = 2;
#[doc = " CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K"]
#[doc = " components in the source image are reordered into image planes, but no"]
#[doc = " colorspace conversion or subsampling is performed.  CMYK JPEG images can"]
#[doc = " only be compressed from and decompressed to packed-pixel images with the"]
#[doc = " CMYK pixel format."]
pub const TJCS_TJCS_CMYK: TJCS = 3;
#[doc = " YCCK colorspace.  YCCK (AKA \"YCbCrK\") is not an absolute colorspace but"]
#[doc = " rather a mathematical transformation of CMYK designed solely for storage"]
#[doc = " and transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be"]
#[doc = " reversibly transformed into YCCK, and as with YCbCr, the chrominance"]
#[doc = " components in the YCCK pixels can be subsampled without incurring major"]
#[doc = " perceptual loss.  YCCK JPEG images can only be compressed from and"]
#[doc = " decompressed to packed-pixel images with the CMYK pixel format."]
pub const TJCS_TJCS_YCCK: TJCS = 4;
#[doc = " JPEG colorspaces"]
pub type TJCS = libc::c_uint;
#[doc = " Error handling behavior"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* Allow the current compression/decompression/transform"]
#[doc = " operation to complete unless a fatal error is encountered."]
#[doc = " - `1` Immediately discontinue the current"]
#[doc = " compression/decompression/transform operation if a warning (non-fatal"]
#[doc = " error) occurs."]
pub const TJPARAM_TJPARAM_STOPONWARNING: TJPARAM = 0;
#[doc = " Row order in packed-pixel source/destination images"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* top-down (X11) order"]
#[doc = " - `1` bottom-up (Windows, OpenGL) order"]
pub const TJPARAM_TJPARAM_BOTTOMUP: TJPARAM = 1;
#[doc = " JPEG destination buffer (re)allocation [compression, lossless"]
#[doc = " transformation]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* Attempt to allocate or reallocate the JPEG destination"]
#[doc = " buffer as needed."]
#[doc = " - `1` Generate an error if the JPEG destination buffer is invalid or too"]
#[doc = " small."]
pub const TJPARAM_TJPARAM_NOREALLOC: TJPARAM = 2;
#[doc = " Perceptual quality of lossy JPEG images [compression only]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `1`-`100` (`1` = worst quality but best compression, `100` = best"]
#[doc = " quality but worst compression) *[no default; must be explicitly"]
#[doc = " specified]*"]
pub const TJPARAM_TJPARAM_QUALITY: TJPARAM = 3;
#[doc = " Chrominance subsampling level"]
#[doc = ""]
#[doc = " The JPEG or YUV image uses (decompression, decoding) or will use (lossy"]
#[doc = " compression, encoding) the specified level of chrominance subsampling."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - One of the @ref TJSAMP \"chrominance subsampling options\" *[no default;"]
#[doc = " must be explicitly specified for lossy compression, encoding, and"]
#[doc = " decoding]*"]
pub const TJPARAM_TJPARAM_SUBSAMP: TJPARAM = 4;
#[doc = " JPEG width (in pixels) [decompression only, read-only]"]
pub const TJPARAM_TJPARAM_JPEGWIDTH: TJPARAM = 5;
#[doc = " JPEG height (in pixels) [decompression only, read-only]"]
pub const TJPARAM_TJPARAM_JPEGHEIGHT: TJPARAM = 6;
#[doc = " JPEG data precision (bits per sample) [decompression only, read-only]"]
#[doc = ""]
#[doc = " The JPEG image uses the specified number of bits per sample."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `8`, `12`, or `16`"]
#[doc = ""]
#[doc = " 12-bit data precision implies #TJPARAM_OPTIMIZE unless #TJPARAM_ARITHMETIC"]
#[doc = " is set."]
pub const TJPARAM_TJPARAM_PRECISION: TJPARAM = 7;
#[doc = " JPEG colorspace"]
#[doc = ""]
#[doc = " The JPEG image uses (decompression) or will use (lossy compression) the"]
#[doc = " specified colorspace."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - One of the @ref TJCS \"JPEG colorspaces\" *[default for lossy compression:"]
#[doc = " automatically selected based on the subsampling level and pixel format]*"]
pub const TJPARAM_TJPARAM_COLORSPACE: TJPARAM = 8;
#[doc = " Chrominance upsampling algorithm [lossy decompression only]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* Use smooth upsampling when decompressing a JPEG image"]
#[doc = " that was compressed using chrominance subsampling.  This creates a smooth"]
#[doc = " transition between neighboring chrominance components in order to reduce"]
#[doc = " upsampling artifacts in the decompressed image."]
#[doc = " - `1` Use the fastest chrominance upsampling algorithm available, which"]
#[doc = " may combine upsampling with color conversion."]
pub const TJPARAM_TJPARAM_FASTUPSAMPLE: TJPARAM = 9;
#[doc = " DCT/IDCT algorithm [lossy compression and decompression]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* Use the most accurate DCT/IDCT algorithm available."]
#[doc = " - `1` Use the fastest DCT/IDCT algorithm available."]
#[doc = ""]
#[doc = " This parameter is provided mainly for backward compatibility with libjpeg,"]
#[doc = " which historically implemented several different DCT/IDCT algorithms"]
#[doc = " because of performance limitations with 1990s CPUs.  In the libjpeg-turbo"]
#[doc = " implementation of the TurboJPEG API:"]
#[doc = " - The \"fast\" and \"accurate\" DCT/IDCT algorithms perform similarly on"]
#[doc = " modern x86/x86-64 CPUs that support AVX2 instructions."]
#[doc = " - The \"fast\" algorithm is generally only about 5-15% faster than the"]
#[doc = " \"accurate\" algorithm on other types of CPUs."]
#[doc = " - The difference in accuracy between the \"fast\" and \"accurate\" algorithms"]
#[doc = " is the most pronounced at JPEG quality levels above 90 and tends to be"]
#[doc = " more pronounced with decompression than with compression."]
#[doc = " - The \"fast\" algorithm degrades and is not fully accelerated for JPEG"]
#[doc = " quality levels above 97, so it will be slower than the \"accurate\""]
#[doc = " algorithm."]
pub const TJPARAM_TJPARAM_FASTDCT: TJPARAM = 10;
#[doc = " Optimized baseline entropy coding [lossy compression only]"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default]* The JPEG image will use the default Huffman tables."]
#[doc = " - `1` Optimal Huffman tables will be computed for the JPEG image.  For"]
#[doc = " lossless transformation, this can also be specified using"]
#[doc = " #TJXOPT_OPTIMIZE."]
#[doc = ""]
#[doc = " Optimized baseline entropy coding will improve compression slightly"]
#[doc = " (generally 5% or less), but it will reduce compression performance"]
#[doc = " considerably."]
pub const TJPARAM_TJPARAM_OPTIMIZE: TJPARAM = 11;
#[doc = " Progressive entropy coding"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default for compression, lossless transformation]* The lossy JPEG"]
#[doc = " image uses (decompression) or will use (compression, lossless"]
#[doc = " transformation) baseline entropy coding."]
#[doc = " - `1` The lossy JPEG image uses (decompression) or will use (compression,"]
#[doc = " lossless transformation) progressive entropy coding.  For lossless"]
#[doc = " transformation, this can also be specified using #TJXOPT_PROGRESSIVE."]
#[doc = ""]
#[doc = " Progressive entropy coding will generally improve compression relative to"]
#[doc = " baseline entropy coding, but it will reduce compression and decompression"]
#[doc = " performance considerably.  Can be combined with #TJPARAM_ARITHMETIC."]
#[doc = " Implies #TJPARAM_OPTIMIZE unless #TJPARAM_ARITHMETIC is also set."]
pub const TJPARAM_TJPARAM_PROGRESSIVE: TJPARAM = 12;
#[doc = " Progressive JPEG scan limit for lossy JPEG images [decompression, lossless"]
#[doc = " transformation]"]
#[doc = ""]
#[doc = " Setting this parameter will cause the decompression and transform"]
#[doc = " functions to return an error if the number of scans in a progressive JPEG"]
#[doc = " image exceeds the specified limit.  The primary purpose of this is to"]
#[doc = " allow security-critical applications to guard against an exploit of the"]
#[doc = " progressive JPEG format described in"]
#[doc = " <a href=\"https://libjpeg-turbo.org/pmwiki/uploads/About/TwoIssueswiththeJPEGStandard.pdf\" target=\"_blank\">this report</a>."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - maximum number of progressive JPEG scans that the decompression and"]
#[doc = " transform functions will process *[default: `0` (no limit)]*"]
#[doc = ""]
#[doc = " @see #TJPARAM_PROGRESSIVE"]
pub const TJPARAM_TJPARAM_SCANLIMIT: TJPARAM = 13;
#[doc = " Arithmetic entropy coding"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default for compression, lossless transformation]* The lossy JPEG"]
#[doc = " image uses (decompression) or will use (compression, lossless"]
#[doc = " transformation) Huffman entropy coding."]
#[doc = " - `1` The lossy JPEG image uses (decompression) or will use (compression,"]
#[doc = " lossless transformation) arithmetic entropy coding.  For lossless"]
#[doc = " transformation, this can also be specified using #TJXOPT_ARITHMETIC."]
#[doc = ""]
#[doc = " Arithmetic entropy coding will generally improve compression relative to"]
#[doc = " Huffman entropy coding, but it will reduce compression and decompression"]
#[doc = " performance considerably.  Can be combined with #TJPARAM_PROGRESSIVE."]
pub const TJPARAM_TJPARAM_ARITHMETIC: TJPARAM = 14;
#[doc = " Lossless JPEG"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default for compression]* The JPEG image is (decompression) or"]
#[doc = " will be (compression) lossy/DCT-based."]
#[doc = " - `1` The JPEG image is (decompression) or will be (compression)"]
#[doc = " lossless/predictive."]
#[doc = ""]
#[doc = " In most cases, compressing and decompressing lossless JPEG images is"]
#[doc = " considerably slower than compressing and decompressing lossy JPEG images."]
#[doc = " Also note that the following features are not available with lossless JPEG"]
#[doc = " images:"]
#[doc = " - Colorspace conversion (lossless JPEG images always use #TJCS_RGB,"]
#[doc = " #TJCS_GRAY, or #TJCS_CMYK, depending on the pixel format of the source"]
#[doc = " image)"]
#[doc = " - Chrominance subsampling (lossless JPEG images always use #TJSAMP_444)"]
#[doc = " - JPEG quality selection"]
#[doc = " - DCT/IDCT algorithm selection"]
#[doc = " - Progressive entropy coding"]
#[doc = " - Arithmetic entropy coding"]
#[doc = " - Compression from/decompression to planar YUV images"]
#[doc = " - Decompression scaling"]
#[doc = " - Lossless transformation"]
#[doc = ""]
#[doc = " @see #TJPARAM_LOSSLESSPSV, #TJPARAM_LOSSLESSPT"]
pub const TJPARAM_TJPARAM_LOSSLESS: TJPARAM = 15;
#[doc = " Lossless JPEG predictor selection value (PSV)"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `1`-`7` *[default for compression: `1`]*"]
#[doc = ""]
#[doc = " @see #TJPARAM_LOSSLESS"]
pub const TJPARAM_TJPARAM_LOSSLESSPSV: TJPARAM = 16;
#[doc = " Lossless JPEG point transform (Pt)"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` through ***precision*** *- 1*, where ***precision*** is the JPEG"]
#[doc = " data precision in bits *[default for compression: `0`]*"]
#[doc = ""]
#[doc = " A point transform value of `0` is necessary in order to generate a fully"]
#[doc = " lossless JPEG image.  (A non-zero point transform value right-shifts the"]
#[doc = " input samples by the specified number of bits, which is effectively a form"]
#[doc = " of lossy color quantization.)"]
#[doc = ""]
#[doc = " @see #TJPARAM_LOSSLESS, #TJPARAM_PRECISION"]
pub const TJPARAM_TJPARAM_LOSSLESSPT: TJPARAM = 17;
#[doc = " JPEG restart marker interval in MCU blocks (lossy) or samples (lossless)"]
#[doc = " [compression only]"]
#[doc = ""]
#[doc = " The nature of entropy coding is such that a corrupt JPEG image cannot"]
#[doc = " be decompressed beyond the point of corruption unless it contains restart"]
#[doc = " markers.  A restart marker stops and restarts the entropy coding algorithm"]
#[doc = " so that, if a JPEG image is corrupted, decompression can resume at the"]
#[doc = " next marker.  Thus, adding more restart markers improves the fault"]
#[doc = " tolerance of the JPEG image, but adding too many restart markers can"]
#[doc = " adversely affect the compression ratio and performance."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - the number of MCU blocks or samples between each restart marker"]
#[doc = " *[default: `0` (no restart markers)]*"]
#[doc = ""]
#[doc = " Setting this parameter to a non-zero value sets #TJPARAM_RESTARTROWS to 0."]
pub const TJPARAM_TJPARAM_RESTARTBLOCKS: TJPARAM = 18;
#[doc = " JPEG restart marker interval in MCU rows (lossy) or sample rows (lossless)"]
#[doc = " [compression only]"]
#[doc = ""]
#[doc = " See #TJPARAM_RESTARTBLOCKS for a description of restart markers."]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - the number of MCU rows or sample rows between each restart marker"]
#[doc = " *[default: `0` (no restart markers)]*"]
#[doc = ""]
#[doc = " Setting this parameter to a non-zero value sets #TJPARAM_RESTARTBLOCKS to"]
#[doc = " 0."]
pub const TJPARAM_TJPARAM_RESTARTROWS: TJPARAM = 19;
#[doc = " JPEG horizontal pixel density"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - The JPEG image has (decompression) or will have (compression) the"]
#[doc = " specified horizontal pixel density *[default for compression: `1`]*."]
#[doc = ""]
#[doc = " This value is stored in or read from the JPEG header.  It does not affect"]
#[doc = " the contents of the JPEG image.  Note that this parameter is set by"]
#[doc = " #tj3LoadImage8() when loading a Windows BMP file that contains pixel"]
#[doc = " density information, and the value of this parameter is stored to a"]
#[doc = " Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNIT"]
#[doc = " is `2`."]
#[doc = ""]
#[doc = " @see TJPARAM_DENSITYUNIT"]
pub const TJPARAM_TJPARAM_XDENSITY: TJPARAM = 20;
#[doc = " JPEG vertical pixel density"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - The JPEG image has (decompression) or will have (compression) the"]
#[doc = " specified vertical pixel density *[default for compression: `1`]*."]
#[doc = ""]
#[doc = " This value is stored in or read from the JPEG header.  It does not affect"]
#[doc = " the contents of the JPEG image.  Note that this parameter is set by"]
#[doc = " #tj3LoadImage8() when loading a Windows BMP file that contains pixel"]
#[doc = " density information, and the value of this parameter is stored to a"]
#[doc = " Windows BMP file by #tj3SaveImage8() if the value of #TJPARAM_DENSITYUNIT"]
#[doc = " is `2`."]
#[doc = ""]
#[doc = " @see TJPARAM_DENSITYUNIT"]
pub const TJPARAM_TJPARAM_YDENSITY: TJPARAM = 21;
#[doc = " JPEG pixel density units"]
#[doc = ""]
#[doc = " **Value**"]
#[doc = " - `0` *[default for compression]* The pixel density of the JPEG image is"]
#[doc = " expressed (decompression) or will be expressed (compression) in unknown"]
#[doc = " units."]
#[doc = " - `1` The pixel density of the JPEG image is expressed (decompression) or"]
#[doc = " will be expressed (compression) in units of pixels/inch."]
#[doc = " - `2` The pixel density of the JPEG image is expressed (decompression) or"]
#[doc = " will be expressed (compression) in units of pixels/cm."]
#[doc = ""]
#[doc = " This value is stored in or read from the JPEG header.  It does not affect"]
#[doc = " the contents of the JPEG image.  Note that this parameter is set by"]
#[doc = " #tj3LoadImage8() when loading a Windows BMP file that contains pixel"]
#[doc = " density information, and the value of this parameter is stored to a"]
#[doc = " Windows BMP file by #tj3SaveImage8() if the value is `2`."]
#[doc = ""]
#[doc = " @see TJPARAM_XDENSITY, TJPARAM_YDENSITY"]
pub const TJPARAM_TJPARAM_DENSITYUNITS: TJPARAM = 22;
#[doc = " Parameters"]
pub type TJPARAM = libc::c_uint;
#[doc = " The error was non-fatal and recoverable, but the destination image may"]
#[doc = " still be corrupt."]
pub const TJERR_TJERR_WARNING: TJERR = 0;
#[doc = " The error was fatal and non-recoverable."]
pub const TJERR_TJERR_FATAL: TJERR = 1;
#[doc = " Error codes"]
pub type TJERR = libc::c_uint;
#[doc = " Do not transform the position of the image pixels"]
pub const TJXOP_TJXOP_NONE: TJXOP = 0;
#[doc = " Flip (mirror) image horizontally.  This transform is imperfect if there"]
#[doc = " are any partial MCU blocks on the right edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_HFLIP: TJXOP = 1;
#[doc = " Flip (mirror) image vertically.  This transform is imperfect if there are"]
#[doc = " any partial MCU blocks on the bottom edge (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_VFLIP: TJXOP = 2;
#[doc = " Transpose image (flip/mirror along upper left to lower right axis.)  This"]
#[doc = " transform is always perfect."]
pub const TJXOP_TJXOP_TRANSPOSE: TJXOP = 3;
#[doc = " Transverse transpose image (flip/mirror along upper right to lower left"]
#[doc = " axis.)  This transform is imperfect if there are any partial MCU blocks in"]
#[doc = " the image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_TRANSVERSE: TJXOP = 4;
#[doc = " Rotate image clockwise by 90 degrees.  This transform is imperfect if"]
#[doc = " there are any partial MCU blocks on the bottom edge (see"]
#[doc = " #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT90: TJXOP = 5;
#[doc = " Rotate image 180 degrees.  This transform is imperfect if there are any"]
#[doc = " partial MCU blocks in the image (see #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT180: TJXOP = 6;
#[doc = " Rotate image counter-clockwise by 90 degrees.  This transform is imperfect"]
#[doc = " if there are any partial MCU blocks on the right edge (see"]
#[doc = " #TJXOPT_PERFECT.)"]
pub const TJXOP_TJXOP_ROT270: TJXOP = 7;
#[doc = " Transform operations for #tj3Transform()"]
pub type TJXOP = libc::c_uint;
#[doc = " Scaling factor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjscalingfactor {
    #[doc = " Numerator"]
    pub num: libc::c_int,
    #[doc = " Denominator"]
    pub denom: libc::c_int,
}
#[test]
fn bindgen_test_layout_tjscalingfactor() {
    assert_eq!(
        ::core::mem::size_of::<tjscalingfactor>(),
        8usize,
        concat!("Size of: ", stringify!(tjscalingfactor))
    );
    assert_eq!(
        ::core::mem::align_of::<tjscalingfactor>(),
        4usize,
        concat!("Alignment of ", stringify!(tjscalingfactor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjscalingfactor>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tjscalingfactor),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjscalingfactor>())).denom as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tjscalingfactor),
            "::",
            stringify!(denom)
        )
    );
}
#[doc = " Cropping region"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjregion {
    #[doc = " The left boundary of the cropping region.  This must be evenly divisible"]
    #[doc = " by the MCU block width (see #tjMCUWidth.)"]
    pub x: libc::c_int,
    #[doc = " The upper boundary of the cropping region.  For lossless transformation,"]
    #[doc = " this must be evenly divisible by the MCU block height (see #tjMCUHeight.)"]
    pub y: libc::c_int,
    #[doc = " The width of the cropping region.  Setting this to 0 is the equivalent of"]
    #[doc = " setting it to the width of the source JPEG image - x."]
    pub w: libc::c_int,
    #[doc = " The height of the cropping region.  Setting this to 0 is the equivalent of"]
    #[doc = " setting it to the height of the source JPEG image - y."]
    pub h: libc::c_int,
}
#[test]
fn bindgen_test_layout_tjregion() {
    assert_eq!(
        ::core::mem::size_of::<tjregion>(),
        16usize,
        concat!("Size of: ", stringify!(tjregion))
    );
    assert_eq!(
        ::core::mem::align_of::<tjregion>(),
        4usize,
        concat!("Alignment of ", stringify!(tjregion))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjregion>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tjregion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjregion>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tjregion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjregion>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tjregion),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjregion>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tjregion),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    pub static TJUNCROPPED: tjregion;
}
#[doc = " Lossless transform"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tjtransform {
    #[doc = " Cropping region"]
    pub r: tjregion,
    #[doc = " One of the @ref TJXOP \"transform operations\""]
    pub op: libc::c_int,
    #[doc = " The bitwise OR of one of more of the @ref TJXOPT_ARITHMETIC"]
    #[doc = " \"transform options\""]
    pub options: libc::c_int,
    #[doc = " Arbitrary data that can be accessed within the body of the callback"]
    #[doc = " function"]
    pub data: *mut libc::c_void,
    #[doc = " A callback function that can be used to modify the DCT coefficients after"]
    #[doc = " they are losslessly transformed but before they are transcoded to a new"]
    #[doc = " JPEG image.  This allows for custom filters or other transformations to be"]
    #[doc = " applied in the frequency domain."]
    #[doc = ""]
    #[doc = " @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:"]
    #[doc = " this pointer is not guaranteed to be valid once the callback returns, so"]
    #[doc = " applications wishing to hand off the DCT coefficients to another function"]
    #[doc = " or library should make a copy of them within the body of the callback.)"]
    #[doc = ""]
    #[doc = " @param arrayRegion #tjregion structure containing the width and height of"]
    #[doc = " the array pointed to by `coeffs` as well as its offset relative to the"]
    #[doc = " component plane.  TurboJPEG implementations may choose to split each"]
    #[doc = " component plane into multiple DCT coefficient arrays and call the callback"]
    #[doc = " function once for each array."]
    #[doc = ""]
    #[doc = " @param planeRegion #tjregion structure containing the width and height of"]
    #[doc = " the component plane to which `coeffs` belongs"]
    #[doc = ""]
    #[doc = " @param componentID ID number of the component plane to which `coeffs`"]
    #[doc = " belongs.  (Y, Cb, and Cr have, respectively, ID's of 0, 1, and 2 in"]
    #[doc = " typical JPEG images.)"]
    #[doc = ""]
    #[doc = " @param transformID ID number of the transformed image to which `coeffs`"]
    #[doc = " belongs.  This is the same as the index of the transform in the"]
    #[doc = " `transforms` array that was passed to #tj3Transform()."]
    #[doc = ""]
    #[doc = " @param transform a pointer to a #tjtransform structure that specifies the"]
    #[doc = " parameters and/or cropping region for this transform"]
    #[doc = ""]
    #[doc = " @return 0 if the callback was successful, or -1 if an error occurred."]
    pub customFilter: ::core::option::Option<
        unsafe extern "C" fn(
            coeffs: *mut libc::c_short,
            arrayRegion: tjregion,
            planeRegion: tjregion,
            componentID: libc::c_int,
            transformID: libc::c_int,
            transform: *mut tjtransform,
        ) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_tjtransform() {
    assert_eq!(
        ::core::mem::size_of::<tjtransform>(),
        40usize,
        concat!("Size of: ", stringify!(tjtransform))
    );
    assert_eq!(
        ::core::mem::align_of::<tjtransform>(),
        8usize,
        concat!("Alignment of ", stringify!(tjtransform))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).op as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(op)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).options as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tjtransform>())).customFilter as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tjtransform),
            "::",
            stringify!(customFilter)
        )
    );
}
#[doc = " TurboJPEG instance handle"]
pub type tjhandle = *mut libc::c_void;
extern "C" {
    pub static TJUNSCALED: tjscalingfactor;
}
extern "C" {
    #[doc = " Create a new TurboJPEG instance."]
    #[doc = ""]
    #[doc = " @param initType one of the @ref TJINIT \"initialization options\""]
    #[doc = ""]
    #[doc = " @return a handle to the newly-created instance, or NULL if an error occurred"]
    #[doc = " (see #tj3GetErrorStr().)"]
    pub fn tj3Init(initType: libc::c_int) -> tjhandle;
}
extern "C" {
    #[doc = " Set the value of a parameter."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param param one of the @ref TJPARAM \"parameters\""]
    #[doc = ""]
    #[doc = " @param value value of the parameter (refer to @ref TJPARAM"]
    #[doc = " \"parameter documentation\")"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3Set(handle: tjhandle, param: libc::c_int, value: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the value of a parameter."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param param one of the @ref TJPARAM \"parameters\""]
    #[doc = ""]
    #[doc = " @return the value of the specified parameter, or -1 if the value is unknown."]
    pub fn tj3Get(handle: tjhandle, param: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress an 8-bit-per-sample packed-pixel RGB, grayscale, or CMYK image into"]
    #[doc = " an 8-bit-per-sample JPEG image."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a packed-pixel RGB, grayscale,"]
    #[doc = " or CMYK source image to be compressed.  This buffer should normally be"]
    #[doc = " `pitch * height` samples in size.  However, you can also use this parameter"]
    #[doc = " to compress from a specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the source image.  Normally this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded."]
    #[doc = " (Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this"]
    #[doc = " parameter to specify the row alignment/padding of the source image, to skip"]
    #[doc = " rows, or to compress from a specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to a byte buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,"]
    #[doc = " or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3JPEGBufSize().  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1, then `*jpegSize` should be set to the size of your"]
    #[doc = " pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,"]
    #[doc = " you should always check `*jpegBuf` upon return from this function, as it may"]
    #[doc = " have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to a size_t variable that holds the size of the JPEG"]
    #[doc = " buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`"]
    #[doc = " should be set to the size of the buffer.  Upon return, `*jpegSize` will"]
    #[doc = " contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a"]
    #[doc = " JPEG buffer that is being reused from a previous call to one of the JPEG"]
    #[doc = " compression functions, then `*jpegSize` is ignored."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3Compress8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress a 12-bit-per-sample packed-pixel RGB, grayscale, or CMYK image into"]
    #[doc = " a 12-bit-per-sample JPEG image."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3Compress8()"]
    pub fn tj3Compress12(
        handle: tjhandle,
        srcBuf: *const libc::c_short,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress a 16-bit-per-sample packed-pixel RGB, grayscale, or CMYK image into"]
    #[doc = " a 16-bit-per-sample lossless JPEG image."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3Compress8()"]
    pub fn tj3Compress16(
        handle: tjhandle,
        srcBuf: *const libc::c_ushort,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress an 8-bit-per-sample unified planar YUV image into an"]
    #[doc = " 8-bit-per-sample JPEG image."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a unified planar YUV source"]
    #[doc = " image to be compressed.  The size of this buffer should match the value"]
    #[doc = " returned by #tj3YUVBufSize() for the given image width, height, row"]
    #[doc = " alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The"]
    #[doc = " Y, U (Cb), and V (Cr) image planes should be stored sequentially in the"]
    #[doc = " buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image.  If the width is not an"]
    #[doc = " even multiple of the MCU block width (see #tjMCUWidth), then an intermediate"]
    #[doc = " buffer copy will be performed."]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the source image (must be a power"]
    #[doc = " of 2.)  Setting this parameter to n indicates that each row in each plane of"]
    #[doc = " the source image is padded to the nearest multiple of n bytes"]
    #[doc = " (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image.  If the height is not"]
    #[doc = " an even multiple of the MCU block height (see #tjMCUHeight), then an"]
    #[doc = " intermediate buffer copy will be performed."]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to a byte buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,"]
    #[doc = " or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3JPEGBufSize().  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1, then `*jpegSize` should be set to the size of your"]
    #[doc = " pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,"]
    #[doc = " you should always check `*jpegBuf` upon return from this function, as it may"]
    #[doc = " have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to a size_t variable that holds the size of the JPEG"]
    #[doc = " buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`"]
    #[doc = " should be set to the size of the buffer.  Upon return, `*jpegSize` will"]
    #[doc = " contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a"]
    #[doc = " JPEG buffer that is being reused from a previous call to one of the JPEG"]
    #[doc = " compression functions, then `*jpegSize` is ignored."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3CompressFromYUV8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Compress a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into"]
    #[doc = " an 8-bit-per-sample JPEG image."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if compressing a grayscale image) that contain a YUV"]
    #[doc = " source image to be compressed.  These planes can be contiguous or"]
    #[doc = " non-contiguous in memory.  The size of each plane should match the value"]
    #[doc = " returned by #tj3YUVPlaneSize() for the given image width, height, strides,"]
    #[doc = " and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\" for more details."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image.  If the width is not an"]
    #[doc = " even multiple of the MCU block width (see #tjMCUWidth), then an intermediate"]
    #[doc = " buffer copy will be performed."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " row in the corresponding plane of the YUV source image.  Setting the stride"]
    #[doc = " for any plane to 0 is the same as setting it to the plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the"]
    #[doc = " strides for all planes will be set to their respective plane widths.  You"]
    #[doc = " can adjust the strides in order to specify an arbitrary amount of row"]
    #[doc = " padding in each plane or to create a JPEG image from a subregion of a larger"]
    #[doc = " planar YUV image."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image.  If the height is not"]
    #[doc = " an even multiple of the MCU block height (see #tjMCUHeight), then an"]
    #[doc = " intermediate buffer copy will be performed."]
    #[doc = ""]
    #[doc = " @param jpegBuf address of a pointer to a byte buffer that will receive the"]
    #[doc = " JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to"]
    #[doc = " accommodate the size of the JPEG image.  Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG buffer with an arbitrary size using #tj3Alloc() and"]
    #[doc = " let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `*jpegBuf` to NULL to tell TurboJPEG to allocate the buffer for you,"]
    #[doc = " or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3JPEGBufSize().  This should ensure that the buffer never has to be"]
    #[doc = " re-allocated.  (Setting #TJPARAM_NOREALLOC guarantees that it won't be.)"]
    #[doc = " ."]
    #[doc = " If you choose option 1, then `*jpegSize` should be set to the size of your"]
    #[doc = " pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,"]
    #[doc = " you should always check `*jpegBuf` upon return from this function, as it may"]
    #[doc = " have changed."]
    #[doc = ""]
    #[doc = " @param jpegSize pointer to a size_t variable that holds the size of the JPEG"]
    #[doc = " buffer.  If `*jpegBuf` points to a pre-allocated buffer, then `*jpegSize`"]
    #[doc = " should be set to the size of the buffer.  Upon return, `*jpegSize` will"]
    #[doc = " contain the size of the JPEG image (in bytes.)  If `*jpegBuf` points to a"]
    #[doc = " JPEG buffer that is being reused from a previous call to one of the JPEG"]
    #[doc = " compression functions, then `*jpegSize` is ignored."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3CompressFromYUVPlanes8(
        handle: tjhandle,
        srcPlanes: *const *const libc::c_uchar,
        width: libc::c_int,
        strides: *const libc::c_int,
        height: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " The maximum size of the buffer (in bytes) required to hold a JPEG image with"]
    #[doc = " the given parameters.  The number of bytes returned by this function is"]
    #[doc = " larger than the size of the uncompressed source image.  The reason for this"]
    #[doc = " is that the JPEG format uses 16-bit coefficients, so it is possible for a"]
    #[doc = " very high-quality source image with very high-frequency content to expand"]
    #[doc = " rather than compress when converted to the JPEG format.  Such images"]
    #[doc = " represent very rare corner cases, but since there is no way to predict the"]
    #[doc = " size of a JPEG image prior to compression, the corner cases have to be"]
    #[doc = " handled."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param jpegSubsamp the level of chrominance subsampling to be used when"]
    #[doc = " generating the JPEG image (see @ref TJSAMP"]
    #[doc = " \"Chrominance subsampling options\".)  #TJSAMP_UNKNOWN is treated like"]
    #[doc = " #TJSAMP_444, since a buffer large enough to hold a JPEG image with no"]
    #[doc = " subsampling should also be large enough to hold a JPEG image with an"]
    #[doc = " arbitrary level of subsampling.  Note that lossless JPEG images always"]
    #[doc = " use #TJSAMP_444."]
    #[doc = ""]
    #[doc = " @return the maximum size of the buffer (in bytes) required to hold the"]
    #[doc = " image, or 0 if the arguments are out of bounds."]
    pub fn tj3JPEGBufSize(
        width: libc::c_int,
        height: libc::c_int,
        jpegSubsamp: libc::c_int,
    ) -> size_t;
}
extern "C" {
    #[doc = " The size of the buffer (in bytes) required to hold a unified planar YUV"]
    #[doc = " image with the given parameters."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the image (must be a power of 2.)"]
    #[doc = " Setting this parameter to n specifies that each row in each plane of the"]
    #[doc = " image will be padded to the nearest multiple of n bytes (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the image"]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the size of the buffer (in bytes) required to hold the image, or 0"]
    #[doc = " if the arguments are out of bounds."]
    pub fn tj3YUVBufSize(
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> size_t;
}
extern "C" {
    #[doc = " The size of the buffer (in bytes) required to hold a YUV image plane with"]
    #[doc = " the given parameters."]
    #[doc = ""]
    #[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the YUV image.  NOTE: this is the width of"]
    #[doc = " the whole image, not the plane width."]
    #[doc = ""]
    #[doc = " @param stride bytes per row in the image plane.  Setting this to 0 is the"]
    #[doc = " equivalent of setting it to the plane width."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the YUV image.  NOTE: this is the height"]
    #[doc = " of the whole image, not the plane height."]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the size of the buffer (in bytes) required to hold the YUV image"]
    #[doc = " plane, or 0 if the arguments are out of bounds."]
    pub fn tj3YUVPlaneSize(
        componentID: libc::c_int,
        width: libc::c_int,
        stride: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> size_t;
}
extern "C" {
    #[doc = " The plane width of a YUV image plane with the given parameters.  Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\" for a description of plane width."]
    #[doc = ""]
    #[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the YUV image"]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the plane width of a YUV image plane with the given parameters, or 0"]
    #[doc = " if the arguments are out of bounds."]
    pub fn tj3YUVPlaneWidth(
        componentID: libc::c_int,
        width: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " The plane height of a YUV image plane with the given parameters.  Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\" for a description of plane height."]
    #[doc = ""]
    #[doc = " @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)"]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the YUV image"]
    #[doc = ""]
    #[doc = " @param subsamp level of chrominance subsampling in the image (see"]
    #[doc = " @ref TJSAMP \"Chrominance subsampling options\".)"]
    #[doc = ""]
    #[doc = " @return the plane height of a YUV image plane with the given parameters, or"]
    #[doc = " 0 if the arguments are out of bounds."]
    pub fn tj3YUVPlaneHeight(
        componentID: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into an"]
    #[doc = " 8-bit-per-sample unified planar YUV image.  This function performs color"]
    #[doc = " conversion (which is accelerated in the libjpeg-turbo implementation) but"]
    #[doc = " does not execute any of the other steps in the JPEG compression process."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale"]
    #[doc = " source image to be encoded.  This buffer should normally be `pitch * height`"]
    #[doc = " bytes in size.  However, you can also use this parameter to encode from a"]
    #[doc = " specific region of a larger buffer."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch bytes per row in the source image.  Normally this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded."]
    #[doc = " (Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this"]
    #[doc = " parameter to specify the row alignment/padding of the source image, to skip"]
    #[doc = " rows, or to encode from a specific region of a larger packed-pixel image."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the unified planar YUV"]
    #[doc = " image.  Use #tj3YUVBufSize() to determine the appropriate size for this"]
    #[doc = " buffer based on the image width, height, row alignment, and level of"]
    #[doc = " chrominance subsampling (see #TJPARAM_SUBSAMP.)  The Y, U (Cb), and V (Cr)"]
    #[doc = " image planes will be stored sequentially in the buffer.  (Refer to"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the YUV image (must be a power of"]
    #[doc = " 2.)  Setting this parameter to n will cause each row in each plane of the"]
    #[doc = " YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)"]
    #[doc = " To generate images suitable for X Video, `align` should be set to 4."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3EncodeYUV8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Encode an 8-bit-per-sample packed-pixel RGB or grayscale image into separate"]
    #[doc = " 8-bit-per-sample Y, U (Cb), and V (Cr) image planes.  This function performs"]
    #[doc = " color conversion (which is accelerated in the libjpeg-turbo implementation)"]
    #[doc = " but does not execute any of the other steps in the JPEG compression process."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " compression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a packed-pixel RGB or grayscale"]
    #[doc = " source image to be encoded.  This buffer should normally be `pitch * height`"]
    #[doc = " bytes in size.  However, you can also use this parameter to encode from a"]
    #[doc = " specific region of a larger buffer."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pitch bytes per row in the source image.  Normally this should be"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>, if the image is unpadded."]
    #[doc = " (Setting this parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can also use this"]
    #[doc = " parameter to specify the row alignment/padding of the source image, to skip"]
    #[doc = " rows, or to encode from a specific region of a larger packed-pixel image."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the source image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if generating a grayscale image) that will receive the"]
    #[doc = " encoded image.  These planes can be contiguous or non-contiguous in memory."]
    #[doc = " Use #tj3YUVPlaneSize() to determine the appropriate size for each plane"]
    #[doc = " based on the image width, height, strides, and level of chrominance"]
    #[doc = " subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes"]
    #[doc = " \"YUV Image Format Notes\" for more details."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " row in the corresponding plane of the YUV image.  Setting the stride for any"]
    #[doc = " plane to 0 is the same as setting it to the plane width (see @ref YUVnotes"]
    #[doc = " \"YUV Image Format Notes\".)  If `strides` is NULL, then the strides for all"]
    #[doc = " planes will be set to their respective plane widths.  You can adjust the"]
    #[doc = " strides in order to add an arbitrary amount of row padding to each plane or"]
    #[doc = " to encode an RGB or grayscale image into a subregion of a larger planar YUV"]
    #[doc = " image."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3EncodeYUVPlanes8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstPlanes: *mut *mut libc::c_uchar,
        strides: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Retrieve information about a JPEG image without decompressing it, or prime"]
    #[doc = " the decompressor with quantization and Huffman tables.  If a JPEG image is"]
    #[doc = " passed to this function, then the @ref TJPARAM \"parameters\" that describe"]
    #[doc = " the JPEG image will be set when the function returns."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing a JPEG image or an"]
    #[doc = " \"abbreviated table specification\" (AKA \"tables-only\") datastream.  Passing a"]
    #[doc = " tables-only datastream to this function primes the decompressor with"]
    #[doc = " quantization and Huffman tables that can be used when decompressing"]
    #[doc = " subsequent \"abbreviated image\" datastreams.  This is useful, for instance,"]
    #[doc = " when decompressing video streams in which all frames share the same"]
    #[doc = " quantization and Huffman tables."]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image or tables-only datastream (in bytes)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecompressHeader(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns a list of fractional scaling factors that the JPEG decompressor"]
    #[doc = " supports."]
    #[doc = ""]
    #[doc = " @param numScalingFactors pointer to an integer variable that will receive"]
    #[doc = " the number of elements in the list"]
    #[doc = ""]
    #[doc = " @return a pointer to a list of fractional scaling factors, or NULL if an"]
    #[doc = " error is encountered (see #tj3GetErrorStr().)"]
    pub fn tj3GetScalingFactors(numScalingFactors: *mut libc::c_int) -> *mut tjscalingfactor;
}
extern "C" {
    #[doc = " Set the scaling factor for subsequent lossy decompression operations."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param scalingFactor #tjscalingfactor structure that specifies a fractional"]
    #[doc = " scaling factor that the decompressor supports (see #tj3GetScalingFactors()),"]
    #[doc = " or <tt>#TJUNSCALED</tt> for no scaling.  Decompression scaling is a function"]
    #[doc = " of the IDCT algorithm, so scaling factors are generally limited to multiples"]
    #[doc = " of 1/8.  If the entire JPEG image will be decompressed, then the width and"]
    #[doc = " height of the scaled destination image can be determined by calling"]
    #[doc = " #TJSCALED() with the JPEG width and height (see #TJPARAM_JPEGWIDTH and"]
    #[doc = " #TJPARAM_JPEGHEIGHT) and the specified scaling factor.  When decompressing"]
    #[doc = " into a planar YUV image, an intermediate buffer copy will be performed if"]
    #[doc = " the width or height of the scaled destination image is not an even multiple"]
    #[doc = " of the MCU block size (see #tjMCUWidth and #tjMCUHeight.)  Note that"]
    #[doc = " decompression scaling is not available (and the specified scaling factor is"]
    #[doc = " ignored) when decompressing lossless JPEG images (see #TJPARAM_LOSSLESS),"]
    #[doc = " since the IDCT algorithm is not used with those images.  Note also that"]
    #[doc = " #TJPARAM_FASTDCT is ignored when decompression scaling is enabled."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SetScalingFactor(handle: tjhandle, scalingFactor: tjscalingfactor) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the cropping region for partially decompressing a lossy JPEG image into"]
    #[doc = " a packed-pixel image"]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param croppingRegion #tjregion structure that specifies a subregion of the"]
    #[doc = " JPEG image to decompress, or <tt>#TJUNCROPPED</tt> for no cropping.  The"]
    #[doc = " left boundary of the cropping region must be evenly divisible by the scaled"]
    #[doc = " MCU block width (<tt>#TJSCALED(#tjMCUWidth[subsamp], scalingFactor)</tt>,"]
    #[doc = " where `subsamp` is the level of chrominance subsampling in the JPEG image"]
    #[doc = " (see #TJPARAM_SUBSAMP) and `scalingFactor` is the decompression scaling"]
    #[doc = " factor (see #tj3SetScalingFactor().)  The cropping region should be"]
    #[doc = " specified relative to the scaled image dimensions.  Unless `croppingRegion`"]
    #[doc = " is <tt>#TJUNCROPPED</tt>, the JPEG header must be read (see"]
    #[doc = " #tj3DecompressHeader()) prior to calling this function."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SetCroppingRegion(handle: tjhandle, croppingRegion: tjregion) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress an 8-bit-per-sample JPEG image into an 8-bit-per-sample"]
    #[doc = " packed-pixel RGB, grayscale, or CMYK image.  The @ref TJPARAM \"parameters\""]
    #[doc = " that describe the JPEG image will be set when this function returns."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing the JPEG image to"]
    #[doc = " decompress"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the packed-pixel"]
    #[doc = " decompressed image.  This buffer should normally be"]
    #[doc = " `pitch * destinationHeight` samples in size.  However, you can also use this"]
    #[doc = " parameter to decompress into a specific region of a larger buffer.  NOTE:"]
    #[doc = " If the JPEG image is lossy, then `destinationHeight` is either the scaled"]
    #[doc = " JPEG height (see #TJSCALED(), #TJPARAM_JPEGHEIGHT, and"]
    #[doc = " #tj3SetScalingFactor()) or the height of the cropping region (see"]
    #[doc = " #tj3SetCroppingRegion().)  If the JPEG image is lossless, then"]
    #[doc = " `destinationHeight` is the JPEG height."]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the destination image.  Normally this should"]
    #[doc = " be set to <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>, if the"]
    #[doc = " destination image should be unpadded.  (Setting this parameter to 0 is the"]
    #[doc = " equivalent of setting it to"]
    #[doc = " <tt>destinationWidth * #tjPixelSize[pixelFormat]</tt>.)  However, you can"]
    #[doc = " also use this parameter to specify the row alignment/padding of the"]
    #[doc = " destination image, to skip rows, or to decompress into a specific region of"]
    #[doc = " a larger buffer.  NOTE: If the JPEG image is lossy, then `destinationWidth`"]
    #[doc = " is either the scaled JPEG width (see #TJSCALED(), #TJPARAM_JPEGWIDTH, and"]
    #[doc = " #tj3SetScalingFactor()) or the width of the cropping region (see"]
    #[doc = " #tj3SetCroppingRegion().)  If the JPEG image is lossless, then"]
    #[doc = " `destinationWidth` is the JPEG width."]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the destination image (see @ref"]
    #[doc = " TJPF \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3Decompress8(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstBuf: *mut libc::c_uchar,
        pitch: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress a 12-bit-per-sample JPEG image into a 12-bit-per-sample"]
    #[doc = " packed-pixel RGB, grayscale, or CMYK image."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3Decompress8()"]
    pub fn tj3Decompress12(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstBuf: *mut libc::c_short,
        pitch: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress a 16-bit-per-sample lossless JPEG image into a 16-bit-per-sample"]
    #[doc = " packed-pixel RGB, grayscale, or CMYK image."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3Decompress8()"]
    pub fn tj3Decompress16(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstBuf: *mut libc::c_ushort,
        pitch: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress an 8-bit-per-sample JPEG image into an 8-bit-per-sample unified"]
    #[doc = " planar YUV image.  This function performs JPEG decompression but leaves out"]
    #[doc = " the color conversion step, so a planar YUV image is generated instead of a"]
    #[doc = " packed-pixel image.  The @ref TJPARAM \"parameters\" that describe the JPEG"]
    #[doc = " image will be set when this function returns."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing the JPEG image to"]
    #[doc = " decompress"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the unified planar YUV"]
    #[doc = " decompressed image.  Use #tj3YUVBufSize() to determine the appropriate size"]
    #[doc = " for this buffer based on the scaled JPEG width and height (see #TJSCALED(),"]
    #[doc = " #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()), row"]
    #[doc = " alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The"]
    #[doc = " Y, U (Cb), and V (Cr) image planes will be stored sequentially in the"]
    #[doc = " buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the YUV image (must be a power of"]
    #[doc = " 2.)  Setting this parameter to n will cause each row in each plane of the"]
    #[doc = " YUV image to be padded to the nearest multiple of n bytes (1 = unpadded.)"]
    #[doc = " To generate images suitable for X Video, `align` should be set to 4."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecompressToYUV8(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstBuf: *mut libc::c_uchar,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decompress an 8-bit-per-sample JPEG image into separate 8-bit-per-sample Y,"]
    #[doc = " U (Cb), and V (Cr) image planes.  This function performs JPEG decompression"]
    #[doc = " but leaves out the color conversion step, so a planar YUV image is generated"]
    #[doc = " instead of a packed-pixel image.  The @ref TJPARAM \"parameters\" that"]
    #[doc = " describe the JPEG image will be set when this function returns."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing the JPEG image to"]
    #[doc = " decompress"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG image (in bytes)"]
    #[doc = ""]
    #[doc = " @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if decompressing a grayscale image) that will receive"]
    #[doc = " the decompressed image.  These planes can be contiguous or non-contiguous in"]
    #[doc = " memory.  Use #tj3YUVPlaneSize() to determine the appropriate size for each"]
    #[doc = " plane based on the scaled JPEG width and height (see #TJSCALED(),"]
    #[doc = " #TJPARAM_JPEGWIDTH, #TJPARAM_JPEGHEIGHT, and #tj3SetScalingFactor()),"]
    #[doc = " strides, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  Refer"]
    #[doc = " to @ref YUVnotes \"YUV Image Format Notes\" for more details."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " row in the corresponding plane of the YUV image.  Setting the stride for any"]
    #[doc = " plane to 0 is the same as setting it to the scaled plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the"]
    #[doc = " strides for all planes will be set to their respective scaled plane widths."]
    #[doc = " You can adjust the strides in order to add an arbitrary amount of row"]
    #[doc = " padding to each plane or to decompress the JPEG image into a subregion of a"]
    #[doc = " larger planar YUV image."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecompressToYUVPlanes8(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        dstPlanes: *mut *mut libc::c_uchar,
        strides: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decode an 8-bit-per-sample unified planar YUV image into an 8-bit-per-sample"]
    #[doc = " packed-pixel RGB or grayscale image.  This function performs color"]
    #[doc = " conversion (which is accelerated in the libjpeg-turbo implementation) but"]
    #[doc = " does not execute any of the other steps in the JPEG decompression process."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param srcBuf pointer to a buffer containing a unified planar YUV source"]
    #[doc = " image to be decoded.  The size of this buffer should match the value"]
    #[doc = " returned by #tj3YUVBufSize() for the given image width, height, row"]
    #[doc = " alignment, and level of chrominance subsampling (see #TJPARAM_SUBSAMP.)  The"]
    #[doc = " Y, U (Cb), and V (Cr) image planes should be stored sequentially in the"]
    #[doc = " source buffer.  (Refer to @ref YUVnotes \"YUV Image Format Notes\".)"]
    #[doc = ""]
    #[doc = " @param align row alignment (in bytes) of the YUV source image (must be a"]
    #[doc = " power of 2.)  Setting this parameter to n indicates that each row in each"]
    #[doc = " plane of the YUV source image is padded to the nearest multiple of n bytes"]
    #[doc = " (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the packed-pixel decoded"]
    #[doc = " image.  This buffer should normally be `pitch * height` bytes in size."]
    #[doc = " However, you can also use this parameter to decode into a specific region of"]
    #[doc = " a larger buffer."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pitch bytes per row in the destination image.  Normally this should"]
    #[doc = " be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination"]
    #[doc = " image should be unpadded.  (Setting this parameter to 0 is the equivalent of"]
    #[doc = " setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can"]
    #[doc = " also use this parameter to specify the row alignment/padding of the"]
    #[doc = " destination image, to skip rows, or to decode into a specific region of a"]
    #[doc = " larger buffer."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the destination image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecodeYUV8(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        align: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Decode a set of 8-bit-per-sample Y, U (Cb), and V (Cr) image planes into an"]
    #[doc = " 8-bit-per-sample packed-pixel RGB or grayscale image.  This function"]
    #[doc = " performs color conversion (which is accelerated in the libjpeg-turbo"]
    #[doc = " implementation) but does not execute any of the other steps in the JPEG"]
    #[doc = " decompression process."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " decompression"]
    #[doc = ""]
    #[doc = " @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes"]
    #[doc = " (or just a Y plane, if decoding a grayscale image) that contain a YUV image"]
    #[doc = " to be decoded.  These planes can be contiguous or non-contiguous in memory."]
    #[doc = " The size of each plane should match the value returned by #tj3YUVPlaneSize()"]
    #[doc = " for the given image width, height, strides, and level of chrominance"]
    #[doc = " subsampling (see #TJPARAM_SUBSAMP.)  Refer to @ref YUVnotes"]
    #[doc = " \"YUV Image Format Notes\" for more details."]
    #[doc = ""]
    #[doc = " @param strides an array of integers, each specifying the number of bytes per"]
    #[doc = " row in the corresponding plane of the YUV source image.  Setting the stride"]
    #[doc = " for any plane to 0 is the same as setting it to the plane width (see"]
    #[doc = " @ref YUVnotes \"YUV Image Format Notes\".)  If `strides` is NULL, then the"]
    #[doc = " strides for all planes will be set to their respective plane widths.  You"]
    #[doc = " can adjust the strides in order to specify an arbitrary amount of row"]
    #[doc = " padding in each plane or to decode a subregion of a larger planar YUV image."]
    #[doc = ""]
    #[doc = " @param dstBuf pointer to a buffer that will receive the packed-pixel decoded"]
    #[doc = " image.  This buffer should normally be `pitch * height` bytes in size."]
    #[doc = " However, you can also use this parameter to decode into a specific region of"]
    #[doc = " a larger buffer."]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pitch bytes per row in the destination image.  Normally this should"]
    #[doc = " be set to <tt>width * #tjPixelSize[pixelFormat]</tt>, if the destination"]
    #[doc = " image should be unpadded.  (Setting this parameter to 0 is the equivalent of"]
    #[doc = " setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.)  However, you can"]
    #[doc = " also use this parameter to specify the row alignment/padding of the"]
    #[doc = " destination image, to skip rows, or to decode into a specific region of a"]
    #[doc = " larger buffer."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the source and destination images"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the destination image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3DecodeYUVPlanes8(
        handle: tjhandle,
        srcPlanes: *const *const libc::c_uchar,
        strides: *const libc::c_int,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Losslessly transform a JPEG image into another JPEG image.  Lossless"]
    #[doc = " transforms work by moving the raw DCT coefficients from one JPEG image"]
    #[doc = " structure to another without altering the values of the coefficients.  While"]
    #[doc = " this is typically faster than decompressing the image, transforming it, and"]
    #[doc = " re-compressing it, lossless transforms are not free.  Each lossless"]
    #[doc = " transform requires reading and performing entropy decoding on all of the"]
    #[doc = " coefficients in the source image, regardless of the size of the destination"]
    #[doc = " image.  Thus, this function provides a means of generating multiple"]
    #[doc = " transformed images from the same source or applying multiple transformations"]
    #[doc = " simultaneously, in order to eliminate the need to read the source"]
    #[doc = " coefficients multiple times."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance that has been initialized for"]
    #[doc = " lossless transformation"]
    #[doc = ""]
    #[doc = " @param jpegBuf pointer to a byte buffer containing the JPEG source image to"]
    #[doc = " transform"]
    #[doc = ""]
    #[doc = " @param jpegSize size of the JPEG source image (in bytes)"]
    #[doc = ""]
    #[doc = " @param n the number of transformed JPEG images to generate"]
    #[doc = ""]
    #[doc = " @param dstBufs pointer to an array of n byte buffers.  `dstBufs[i]` will"]
    #[doc = " receive a JPEG image that has been transformed using the parameters in"]
    #[doc = " `transforms[i]`.  TurboJPEG has the ability to reallocate the JPEG"]
    #[doc = " destination buffer to accommodate the size of the transformed JPEG image."]
    #[doc = " Thus, you can choose to:"]
    #[doc = " -# pre-allocate the JPEG destination buffer with an arbitrary size using"]
    #[doc = " #tj3Alloc() and let TurboJPEG grow the buffer as needed,"]
    #[doc = " -# set `dstBufs[i]` to NULL to tell TurboJPEG to allocate the buffer for"]
    #[doc = " you, or"]
    #[doc = " -# pre-allocate the buffer to a \"worst case\" size determined by calling"]
    #[doc = " #tj3JPEGBufSize() with the transformed or cropped width and height and the"]
    #[doc = " level of subsampling used in the source image.  Under normal circumstances,"]
    #[doc = " this should ensure that the buffer never has to be re-allocated.  (Setting"]
    #[doc = " #TJPARAM_NOREALLOC guarantees that it won't be.)  Note, however, that there"]
    #[doc = " are some rare cases (such as transforming images with a large amount of"]
    #[doc = " embedded EXIF or ICC profile data) in which the transformed JPEG image will"]
    #[doc = " be larger than the worst-case size, and #TJPARAM_NOREALLOC cannot be used in"]
    #[doc = " those cases."]
    #[doc = " ."]
    #[doc = " If you choose option 1, then `dstSizes[i]` should be set to the size of your"]
    #[doc = " pre-allocated buffer.  In any case, unless you have set #TJPARAM_NOREALLOC,"]
    #[doc = " you should always check `dstBufs[i]` upon return from this function, as it"]
    #[doc = " may have changed."]
    #[doc = ""]
    #[doc = " @param dstSizes pointer to an array of n size_t variables that will receive"]
    #[doc = " the actual sizes (in bytes) of each transformed JPEG image.  If `dstBufs[i]`"]
    #[doc = " points to a pre-allocated buffer, then `dstSizes[i]` should be set to the"]
    #[doc = " size of the buffer.  Upon return, `dstSizes[i]` will contain the size of the"]
    #[doc = " transformed JPEG image (in bytes.)"]
    #[doc = ""]
    #[doc = " @param transforms pointer to an array of n #tjtransform structures, each of"]
    #[doc = " which specifies the transform parameters and/or cropping region for the"]
    #[doc = " corresponding transformed JPEG image."]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr()"]
    #[doc = " and #tj3GetErrorCode().)"]
    pub fn tj3Transform(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: size_t,
        n: libc::c_int,
        dstBufs: *mut *mut libc::c_uchar,
        dstSizes: *mut size_t,
        transforms: *const tjtransform,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Destroy a TurboJPEG instance."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance.  If the handle is NULL, then"]
    #[doc = " this function has no effect."]
    pub fn tj3Destroy(handle: tjhandle);
}
extern "C" {
    #[doc = " Allocate a byte buffer for use with TurboJPEG.  You should always use this"]
    #[doc = " function to allocate the JPEG destination buffer(s) for the compression and"]
    #[doc = " transform functions unless you are disabling automatic buffer (re)allocation"]
    #[doc = " (by setting #TJPARAM_NOREALLOC.)"]
    #[doc = ""]
    #[doc = " @param bytes the number of bytes to allocate"]
    #[doc = ""]
    #[doc = " @return a pointer to a newly-allocated buffer with the specified number of"]
    #[doc = " bytes."]
    #[doc = ""]
    #[doc = " @see tj3Free()"]
    pub fn tj3Alloc(bytes: size_t) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Load an 8-bit-per-sample packed-pixel image from disk into memory."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param filename name of a file containing a packed-pixel image in Windows"]
    #[doc = " BMP or PBMPLUS (PPM/PGM) format.  Windows BMP files require 8-bit-per-sample"]
    #[doc = " data precision.  If the data precision of the PBMPLUS file does not match"]
    #[doc = " the target data precision, then upconverting or downconverting will be"]
    #[doc = " performed."]
    #[doc = ""]
    #[doc = " @param width pointer to an integer variable that will receive the width (in"]
    #[doc = " pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param align row alignment (in samples) of the packed-pixel buffer to be"]
    #[doc = " returned (must be a power of 2.)  Setting this parameter to n will cause all"]
    #[doc = " rows in the buffer to be padded to the nearest multiple of n samples"]
    #[doc = " (1 = unpadded.)"]
    #[doc = ""]
    #[doc = " @param height pointer to an integer variable that will receive the height"]
    #[doc = " (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pointer to an integer variable that specifies or will"]
    #[doc = " receive the pixel format of the packed-pixel buffer.  The behavior of this"]
    #[doc = " function will vary depending on the value of `*pixelFormat` passed to the"]
    #[doc = " function:"]
    #[doc = " - @ref TJPF_UNKNOWN : The packed-pixel buffer returned by this function will"]
    #[doc = " use the most optimal pixel format for the file type, and `*pixelFormat` will"]
    #[doc = " contain the ID of that pixel format upon successful return from this"]
    #[doc = " function."]
    #[doc = " - @ref TJPF_GRAY : Only PGM files and 8-bit-per-pixel BMP files with a"]
    #[doc = " grayscale colormap can be loaded."]
    #[doc = " - @ref TJPF_CMYK : The RGB or grayscale pixels stored in the file will be"]
    #[doc = " converted using a quick & dirty algorithm that is suitable only for testing"]
    #[doc = " purposes.  (Proper conversion between CMYK and other formats requires a"]
    #[doc = " color management system.)"]
    #[doc = " - Other @ref TJPF \"pixel formats\" : The packed-pixel buffer will use the"]
    #[doc = " specified pixel format, and pixel format conversion will be performed if"]
    #[doc = " necessary."]
    #[doc = ""]
    #[doc = " @return a pointer to a newly-allocated buffer containing the packed-pixel"]
    #[doc = " image, converted to the chosen pixel format and with the chosen row"]
    #[doc = " alignment, or NULL if an error occurred (see #tj3GetErrorStr().)  This"]
    #[doc = " buffer should be freed using #tj3Free()."]
    pub fn tj3LoadImage8(
        handle: tjhandle,
        filename: *const libc::c_char,
        width: *mut libc::c_int,
        align: libc::c_int,
        height: *mut libc::c_int,
        pixelFormat: *mut libc::c_int,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " Load a 12-bit-per-sample packed-pixel image from disk into memory."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3LoadImage8()"]
    pub fn tj3LoadImage12(
        handle: tjhandle,
        filename: *const libc::c_char,
        width: *mut libc::c_int,
        align: libc::c_int,
        height: *mut libc::c_int,
        pixelFormat: *mut libc::c_int,
    ) -> *mut libc::c_short;
}
extern "C" {
    #[doc = " Load a 16-bit-per-sample packed-pixel image from disk into memory."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3LoadImage8()"]
    pub fn tj3LoadImage16(
        handle: tjhandle,
        filename: *const libc::c_char,
        width: *mut libc::c_int,
        align: libc::c_int,
        height: *mut libc::c_int,
        pixelFormat: *mut libc::c_int,
    ) -> *mut libc::c_ushort;
}
extern "C" {
    #[doc = " Save an 8-bit-per-sample packed-pixel image from memory to disk."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @param filename name of a file to which to save the packed-pixel image.  The"]
    #[doc = " image will be stored in Windows BMP or PBMPLUS (PPM/PGM) format, depending"]
    #[doc = " on the file extension.  Windows BMP files require 8-bit-per-sample data"]
    #[doc = " precision."]
    #[doc = ""]
    #[doc = " @param buffer pointer to a buffer containing a packed-pixel RGB, grayscale,"]
    #[doc = " or CMYK image to be saved"]
    #[doc = ""]
    #[doc = " @param width width (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pitch samples per row in the packed-pixel image.  Setting this"]
    #[doc = " parameter to 0 is the equivalent of setting it to"]
    #[doc = " <tt>width * #tjPixelSize[pixelFormat]</tt>."]
    #[doc = ""]
    #[doc = " @param height height (in pixels) of the packed-pixel image"]
    #[doc = ""]
    #[doc = " @param pixelFormat pixel format of the packed-pixel image (see @ref TJPF"]
    #[doc = " \"Pixel formats\".)  If this parameter is set to @ref TJPF_GRAY, then the"]
    #[doc = " image will be stored in PGM or 8-bit-per-pixel (indexed color) BMP format."]
    #[doc = " Otherwise, the image will be stored in PPM or 24-bit-per-pixel BMP format."]
    #[doc = " If this parameter is set to @ref TJPF_CMYK, then the CMYK pixels will be"]
    #[doc = " converted to RGB using a quick & dirty algorithm that is suitable only for"]
    #[doc = " testing purposes.  (Proper conversion between CMYK and other formats"]
    #[doc = " requires a color management system.)"]
    #[doc = ""]
    #[doc = " @return 0 if successful, or -1 if an error occurred (see #tj3GetErrorStr().)"]
    pub fn tj3SaveImage8(
        handle: tjhandle,
        filename: *const libc::c_char,
        buffer: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Save a 12-bit-per-sample packed-pixel image from memory to disk."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3SaveImage8()"]
    pub fn tj3SaveImage12(
        handle: tjhandle,
        filename: *const libc::c_char,
        buffer: *const libc::c_short,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Save a 16-bit-per-sample packed-pixel image from memory to disk."]
    #[doc = ""]
    #[doc = " \\details \\copydetails tj3SaveImage8()"]
    pub fn tj3SaveImage16(
        handle: tjhandle,
        filename: *const libc::c_char,
        buffer: *const libc::c_ushort,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Free a byte buffer previously allocated by TurboJPEG.  You should always use"]
    #[doc = " this function to free JPEG destination buffer(s) that were automatically"]
    #[doc = " (re)allocated by the compression and transform functions or that were"]
    #[doc = " manually allocated using #tj3Alloc()."]
    #[doc = ""]
    #[doc = " @param buffer address of the buffer to free.  If the address is NULL, then"]
    #[doc = " this function has no effect."]
    #[doc = ""]
    #[doc = " @see tj3Alloc()"]
    pub fn tj3Free(buffer: *mut libc::c_void);
}
extern "C" {
    #[doc = " Returns a descriptive error message explaining why the last command failed."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance, or NULL if the error was"]
    #[doc = " generated by a global function (but note that retrieving the error message"]
    #[doc = " for a global function is thread-safe only on platforms that support"]
    #[doc = " thread-local storage.)"]
    #[doc = ""]
    #[doc = " @return a descriptive error message explaining why the last command failed."]
    pub fn tj3GetErrorStr(handle: tjhandle) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Returns a code indicating the severity of the last error.  See"]
    #[doc = " @ref TJERR \"Error codes\"."]
    #[doc = ""]
    #[doc = " @param handle handle to a TurboJPEG instance"]
    #[doc = ""]
    #[doc = " @return a code indicating the severity of the last error.  See"]
    #[doc = " @ref TJERR \"Error codes\"."]
    pub fn tj3GetErrorCode(handle: tjhandle) -> libc::c_int;
}
extern "C" {
    pub fn TJBUFSIZE(width: libc::c_int, height: libc::c_int) -> libc::c_ulong;
}
extern "C" {
    pub fn tjCompress(
        handle: tjhandle,
        srcBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelSize: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        compressedSize: *mut libc::c_ulong,
        jpegSubsamp: libc::c_int,
        jpegQual: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompress(
        handle: tjhandle,
        jpegBuf: *mut libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelSize: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressHeader(
        handle: tjhandle,
        jpegBuf: *mut libc::c_uchar,
        jpegSize: libc::c_ulong,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDestroy(handle: tjhandle) -> libc::c_int;
}
extern "C" {
    pub fn tjGetErrorStr() -> *mut libc::c_char;
}
extern "C" {
    pub fn tjInitCompress() -> tjhandle;
}
extern "C" {
    pub fn tjInitDecompress() -> tjhandle;
}
extern "C" {
    pub fn TJBUFSIZEYUV(
        width: libc::c_int,
        height: libc::c_int,
        jpegSubsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjDecompressHeader2(
        handle: tjhandle,
        jpegBuf: *mut libc::c_uchar,
        jpegSize: libc::c_ulong,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
        jpegSubsamp: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressToYUV(
        handle: tjhandle,
        jpegBuf: *mut libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstBuf: *mut libc::c_uchar,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjEncodeYUV(
        handle: tjhandle,
        srcBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelSize: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        subsamp: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjAlloc(bytes: libc::c_int) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn tjBufSize(
        width: libc::c_int,
        height: libc::c_int,
        jpegSubsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjBufSizeYUV(
        width: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjCompress2(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut libc::c_ulong,
        jpegSubsamp: libc::c_int,
        jpegQual: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompress2(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjEncodeYUV2(
        handle: tjhandle,
        srcBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        subsamp: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjFree(buffer: *mut libc::c_uchar);
}
extern "C" {
    pub fn tjGetScalingFactors(numscalingfactors: *mut libc::c_int) -> *mut tjscalingfactor;
}
extern "C" {
    pub fn tjInitTransform() -> tjhandle;
}
extern "C" {
    pub fn tjTransform(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        n: libc::c_int,
        dstBufs: *mut *mut libc::c_uchar,
        dstSizes: *mut libc::c_ulong,
        transforms: *mut tjtransform,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjBufSizeYUV2(
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjCompressFromYUV(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut libc::c_ulong,
        jpegQual: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjCompressFromYUVPlanes(
        handle: tjhandle,
        srcPlanes: *mut *const libc::c_uchar,
        width: libc::c_int,
        strides: *const libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
        jpegBuf: *mut *mut libc::c_uchar,
        jpegSize: *mut libc::c_ulong,
        jpegQual: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecodeYUV(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        align: libc::c_int,
        subsamp: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecodeYUVPlanes(
        handle: tjhandle,
        srcPlanes: *mut *const libc::c_uchar,
        strides: *const libc::c_int,
        subsamp: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressHeader3(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
        jpegSubsamp: *mut libc::c_int,
        jpegColorspace: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressToYUV2(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstBuf: *mut libc::c_uchar,
        width: libc::c_int,
        align: libc::c_int,
        height: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjDecompressToYUVPlanes(
        handle: tjhandle,
        jpegBuf: *const libc::c_uchar,
        jpegSize: libc::c_ulong,
        dstPlanes: *mut *mut libc::c_uchar,
        width: libc::c_int,
        strides: *mut libc::c_int,
        height: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjEncodeYUV3(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstBuf: *mut libc::c_uchar,
        align: libc::c_int,
        subsamp: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjEncodeYUVPlanes(
        handle: tjhandle,
        srcBuf: *const libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        dstPlanes: *mut *mut libc::c_uchar,
        strides: *mut libc::c_int,
        subsamp: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjPlaneHeight(
        componentID: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjPlaneSizeYUV(
        componentID: libc::c_int,
        width: libc::c_int,
        stride: libc::c_int,
        height: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn tjPlaneWidth(
        componentID: libc::c_int,
        width: libc::c_int,
        subsamp: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn tjGetErrorCode(handle: tjhandle) -> libc::c_int;
}
extern "C" {
    pub fn tjGetErrorStr2(handle: tjhandle) -> *mut libc::c_char;
}
extern "C" {
    pub fn tjLoadImage(
        filename: *const libc::c_char,
        width: *mut libc::c_int,
        align: libc::c_int,
        height: *mut libc::c_int,
        pixelFormat: *mut libc::c_int,
        flags: libc::c_int,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    pub fn tjSaveImage(
        filename: *const libc::c_char,
        buffer: *mut libc::c_uchar,
        width: libc::c_int,
        pitch: libc::c_int,
        height: libc::c_int,
        pixelFormat: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
